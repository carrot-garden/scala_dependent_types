<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<title>Dependent Types in Scala - Some Tips, Tricks and Techniques</title>

		<meta name="description" content="Dependent Types in Scala - Tips, Tricks and Techniques">
		<meta name="author" content="Owein Reese">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/reveal.min.css">
		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/theme/sky.css" id="theme">
		<link rel="stylesheet" href="scala.css">
	</head>

	<body>
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Dependent Types</h2>
					<h3>Through the Looking Glass</h3>
					<p>
						<small><a href="https://twitter.com/OweinReese">@OweinReese</a></small>
					</p>
				</section>
				<section>
					<section>
						<h3>Quick Review</h3>
					</section>
					<section>
						<h4>A Nested Class, Trait or Object</h4>
						<pre>
<span class="k">trait</span> <span class="nc">Foo</span><span class="o">{</span>
  <span class="k">class</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">use</span><span class="o">(</span><span class="n">bar</span><span class="k">:</span> <span class="kt">Bar</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<pre>
<span class="k">val</span> <span class="n">foo</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Foo</span><span class="o">{}</span>
<span class="k">val</span> <span class="n">fooBar</span> <span class="k">=</span> <span class="k">new</span> <span class="n">foo</span><span class="o">.</span><span class="nc">Bar</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oh</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Foo</span><span class="o">{}</span>
<span class="k">val</span> <span class="n">ohBar</span> <span class="k">=</span> <span class="k">new</span> <span class="n">oh</span><span class="o">.</span><span class="nc">Bar</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">foo.use(fooBar)</span>
						</pre>
					</section>
					<section>
						<h4>Abstract Types</h4>
						<pre>
<span class="k">trait</span> <span class="nc">Foo</span><span class="o">{</span>
  <span class="k">type</span> <span class="kt">Bar</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Bar</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<pre>
<span class="k">def</span> <span class="n">bar</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span><span class="k">:</span> <span class="kt">foo.Bar</span>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h3>Standard Library</h3>
					</section>
					<section>
						<pre>
<span class="k">trait</span> <span class="nc">IsTraversableLike</span><span class="o">[</span><span class="kt">Repr</span><span class="o">]{</span>
  <span class="k">type</span> <span class="kt">A</span>
  <span class="k">def</span> <span class="n">conversion</span><span class="o">(</span><span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">GenTraversableLike</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span>
<span class="o">}</span>
						</pre>
					</section>
					<section></section>
				</section>
				<section>
					<section>
						<h2>Functions</h2>
						<p>You always know what's going in</p>
						<pre>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-In</span>, <span class="kt">+Out</span><span class="o">]</span>{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">In</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span>
<span class="o">}</span>
						</pre>
						<p>...and what's coming out.</p>
					</section>
					<section>
						<h3>Standard Library Version</h3>
						<pre>
<span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-T1</span>, <span class="kt">+R</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AnyRef</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">T1</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>

  <span class="k">def</span> <span class="n">andThen</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">T1</span> <span class="o">=&gt;</span> <span class="n">A</span> <span class="k">=</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">compose</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">T1</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span> <span class="k">=</span> <span class="n">g</span> <span class="n">andThen</span> <span class="n">self</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="s">&quot;&lt;function1&gt;&quot;</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<h3>Context is Everything</h3>
						<pre>

<span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">M[B]</span>

<span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M[B]</span><span class="o">)</span><span class="k">:</span> <span class="kt">M[B]</span>
						</pre>
						<p>They make you declare your types before using them.</p>
					</section>
					<section>
						<h3>In Wonderland</h3>
						<pre>
<span class="k">trait</span> <span class="nc">DepFun1</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">type</span> <span class="kt">R</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
<span class="o">}</span>
						</pre>
						<p>What an odd world we've stepped into.</p>
						<pre>

<span class="k">def</span> <span class="n">map</span>(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1[A]</span><span class="o">)</span><span class="k">:</span> <span class="kt">M[f.R]</span>

<span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1[A]</span><span class="o">)</span><span class="k">:</span> <span class="kt">M[???]</span>
						</pre>
					</section>
					<section>
						<h3>Dependently Typed Function</h3>
						<pre>
<span class="k">trait</span> <span class="nc">DepFun1</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AnyRef</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">type</span> <span class="kt">R</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>

  <span class="k">def</span> <span class="n">andThen</span><span class="o">(</span><span class="n">dep</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">R</span>

    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">dep.R</span> <span class="o">=</span> <span class="n">dep</span><span class="o">(</span><span class="n">self</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="s">&quot;&lt;function1&gt;&quot;</span>
<span class="o">}</span>
						</pre>
						<p>*we will revisit compose later</p>
					</section>
				</section>
				<section>
					<section>
						<h3>Bind our Types</h3>
						<pre>

<span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1[A]</span><span class="o">)</span><span class="k">:</span> <span class="kt">M[???]</span>
						</pre>
						<p>How do we place type constraints on a type we can't directly access?</p>
					</section>
					<section>
						<h3>Ideas From Scala Itself</h3>
						<pre>
<span class="k">trait</span> <span class="nc">IsTraversableLike</span><span class="o">[</span><span class="kt">Repr</span><span class="o">]{</span>
  <span class="k">type</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="n">conversion</span><span class="o">(</span><span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">GenTraversableLike</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<h3>Typesafe Conversion</h3>
						<pre>

<span class="k">trait</span> <span class="nc">IsHigherKind</span><span class="o">[</span><span class="kt">MA</span><span class="o">]{</span>
  <span class="k">type</span> <span class="kt">A</span>
  <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">ma</span><span class="k">:</span> <span class="kt">MA</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">to</span><span class="o">(</span><span class="n">ma</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">MA</span>
<span class="o">}</span>
						</pre>
						<p>Also a compile time guard</p>
					</section>
					<section>
						<h3>Why Dependent Types?</h3>
						<pre>

<span class="k">trait</span> <span class="nc">IsTraversableLike</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">A</span><span class="o">]{</span>
  <span class="k">def</span> <span class="n">conversion</span><span class="o">(</span><span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">GenTraversableLike</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Repr</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">){</span>
  <span class="k">def</span> <span class="n">magnitude</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">itl</span><span class="k">:</span> <span class="kt">IsTraversableLike</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">itl</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="n">size</span>
<span class="o">}</span>
						</pre>
						<p>Talk about adding that type parameter and api design.</p>
					</section>
				</section>
				<section>
					<section>
						<h3>Continuing On</h3>
						<p>Ever seen a signature like this?</p>
						<pre>

						</pre>
					</section>
					<section>
						<h3>The Continuation Monad</h3>
						<pre>
<span class="k">trait</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">+T</span>, <span class="kt">R</span><span class="o">]{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cont</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">R</span><span class="o">]{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">self</span><span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="n">g</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cont</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">R</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">R</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">self</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="k">_</span><span class="o">)(</span><span class="n">g</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<h3>In Wonderland</h3>
						<pre>

						</pre>
						<p>Things are a little different</p>
					</section>
					<section>
						<h3>Title</h3>
						<pre>

<span class="k">trait</span> <span class="nc">DepCont</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">dep</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">dep.R</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">tie</span><span class="k">:</span> <span class="kt">Tie</span><span class="o">[</span><span class="kt">f.R</span><span class="o">])</span> <span class="k">=</span> <span class="n">dmap</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">tie</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">tie</span><span class="k">:</span> <span class="kt">Tie</span><span class="o">[</span><span class="kt">f.R</span><span class="o">])</span> <span class="k">=</span> <span class="n">dmap</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">tie</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">dmap</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">tie</span><span class="k">:</span> <span class="kt">Tie</span><span class="o">[</span><span class="kt">f.R</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">DepCont</span><span class="o">[</span><span class="kt">tie.In</span><span class="o">]{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">dep</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">tie.In</span><span class="o">])</span><span class="k">:</span> <span class="kt">dep.R</span> <span class="o">=</span> <span class="n">self</span><span class="o">(</span><span class="k">new</span> <span class="nc">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">]{</span>
      <span class="k">type</span> <span class="kt">R</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">R</span>

      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">tie</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">dep</span><span class="o">)</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<h3>Automatic Type</h3>
						<pre>

<span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">tie</span><span class="k">:</span> <span class="kt">Tie</span><span class="o">[</span><span class="kt">f.R</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">tie.In</span><span class="o">]</span>

<span class="k">def</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">tie</span><span class="k">:</span> <span class="kt">Tie</span><span class="o">[</span><span class="kt">f.R</span><span class="o">])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">tie.In</span><span class="o">]</span>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h3>The Rules of "Tie"</h3>
						<pre>

<span class="k">trait</span> <span class="nc">Tie</span><span class="o">[</span><span class="kt">R</span><span class="o">]{</span>
  <span class="k">type</span> <span class="kt">In</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">In</span><span class="o">])</span><span class="k">:</span> <span class="kt">f.R</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<h3>Defining</h3>
						<pre>
<span class="k">object</span> <span class="nc">Tie</span> <span class="k">extends</span> <span class="nc">LowPriorityTie</span><span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="k">implicit</span> <span class="n">tie</span><span class="k">:</span> <span class="kt">Tie</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">tie.In</span><span class="o">]</span> <span class="k">=</span> <span class="n">tie</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">tieFM</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">DepCont</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span>, <span class="kt">R</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Tie</span><span class="o">[</span><span class="kt">DepCont</span><span class="o">[</span><span class="kt">R</span><span class="o">]]{</span>
      <span class="k">type</span> <span class="kt">In</span> <span class="o">=</span> <span class="n">R</span>

      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">DepCont</span><span class="o">[</span><span class="kt">R</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">f.R</span> <span class="o">=</span> <span class="n">r</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">LowPriorityTie</span><span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">In0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tie</span><span class="o">[</span><span class="kt">R</span><span class="o">]{</span> <span class="k">type</span> <span class="kt">In</span> <span class="o">=</span> <span class="nc">In0</span> <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">tieF</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">R</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Tie</span><span class="o">[</span><span class="kt">R</span><span class="o">]{</span>
      <span class="k">type</span> <span class="kt">In</span> <span class="o">=</span> <span class="n">R</span>

      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">R</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">DepFun1</span><span class="o">[</span><span class="kt">R</span><span class="o">])</span><span class="k">:</span> <span class="kt">f.R</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
						</pre>
					</section>
					<section>
						<h3>Question</h3>
						<pre>
<span class="nc">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>

						</pre>
						<pre class="fragment">
<span class="nc">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]]]</span>

						</pre>
						<pre class="fragment">
<span class="nc">StateMonad</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span>

						</pre>
						<pre class="fragment">
<span class="nc">StateMonad</span><span class="o">[</span><span class="kt">S1</span>, <span class="kt">StateMonad</span><span class="o">[</span><span class="kt">S2</span>, <span class="kt">StateMonad</span><span class="o">[</span><span class="kt">S3</span>, <span class="kt">StateMonad</span><span class="o">[</span><span class="kt">S4</span>, <span class="kt">A</span><span class="o">]]]]</span>
						</pre>
					</section>
				</section>
				<section></section>
			</div>

			<div style="position: fixed; display: block; left: 10px; bottom: 10px">
				<img src="../Scala-Dep-Types/MediaMath_Logo_Border_CMYK_notagline.png">
			</div>

		</div>

		<script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/head.min.js"></script>
		<script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/js/reveal.min.js"></script>

		<script>
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				overview: true,
				touch: true,
				theme: 'sky',
				transition: 'slide', // none/fade/slide/convex/concave/zoom
				minScale: 0.7,
				maxScale: 1.0,

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				dependencies: [
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/classList.js', 
						condition: function() { return !document.body.classList; } 
					}/*,
					{
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/markdown/marked.js', 
						condition: function() { return !!document.querySelector( '[data-markdown]' ); } 
					},
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/markdown/markdown.js', 
						condition: function() { return !!document.querySelector( '[data-markdown]' ); } 
					}*/
				]
			});

		</script>


	</body>
</html>
