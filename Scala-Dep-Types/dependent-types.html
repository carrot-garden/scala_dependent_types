
<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Dependent Types in Scala - Some Tips, Tricks and Techniques</title>

		<meta name="description" content="Dependent Types in Scala - Tips, Tricks and Techniques">
		<meta name="author" content="Owein Reese">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/reveal.min.css">
		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/css/zenburn.css">

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Dependent Types in Scala</h1>
					<h3>Some Tips, Tricks and Techniques</h3>
					<p>
						<small><a href="https://twitter.com/OweinReese">@OweinReese</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>What is a Dependent Type?</h2>
						<div class="fragment">
							<pre><code data-trim>
trait DepValue{
  type V
  val value: V
}

def magic(that: DepValue): that.V = that.value
							</code></pre>
						</div>
						<p class="fragment">The return type of "magic" <i>depends</i> on the argument passed in.</p>
					</section>
					<section>
						<h4>Toy Example</h4>
						<pre><code trim-data>
def mk[T](x: T) = new DepValue{ 
  type V = T
  val value = x
}
val depInt = mk(1)
val depString = mk("two")

val itWorks: Int = magic(depInt)
val again: String = magic(depString)
						</code></pre>
					</section>
					<section>
						<h4>In the Standard Library</h4>
						<pre><code trim-data>
package scala.collection.generic

trait IsTraversableOnce[Repr]{
  type A
  val conversion: Repr => GenTraversableOnce[A]
}

trait IsTraversableLike[Repr]{
  type A
  def conversion(repr: Repr): GenTraversableLike[A, Repr]
}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h3>Start With Some Basics</h3>
						<div class="fragment">
							<p>The most basic dependent type in existence</p>
							<pre><code trim-data>
trait DepT{
  type T
}
							</code></pre>
							<p>...is also practically useless</p>
						</div>
					</section>
					<section>
						<h3>Make it More Useful</h3>
						<pre><code trim-data>
trait Inner[F]{
  type T
}
						</code></pre>
						<div class="fragment">
							<pre><code trim-data>
object Inner{
  def apply[F](implicit inner: Inner[F]) = inner

  implicit def mk[F[_], A] = new Inner[F[A]]{
    type T = A
  }
}
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Now Make use of the Types</h3>
						<pre><code trim-data>
trait IsFuture[F]{
  type T

  def apply(f: F): Future[T]
}

object IsFuture{
  def apply[F](implicit isf: IsFuture[F]) = isf

  implicit def mk[A] = new IsFuture[Future[A]]{
    type T = A

    def apply(f: F): Future[A] = f
  }
}
						</code></pre>
						<p class="fragment">Think about how IsTraversableOnce was implemented?</p>
					</section>
					<section>
						<h3>Use as an Implicit Guard</h3>
						<pre><code trim-data>
def logResult[Thing](thing: Thing)(implicit isf: IsFuture[Thing]): Future[isf.A] = 
  isf(thing) map{ x =>
    log info s"I got a result of $x"
    x
  }
  						</code></pre>
  						<p>Here, IsFuture witnesses that the type "Thing" is a Future and allows us to convert it to it's explicit and fully qualified type.</p>
					</section>
					<section>
						<h4>Take Away</h4>
						<ol>
							<li>Use companion objects to hide implicit creation and any other boilerplate that might be needed to ultimately construct the dependently typed object.</li>
							<li>Expose the constructed type classes using an apply that returns the implicit sought.</li>
							<li>Dependent types can used as type parameters</li>
							<li>Dependent types allow us to safely cross type boundaries.</li>
							<li>You get one "free" type parameter.</li>
						</ol>
					</section>
				</section>

				<section>
					<section>
						<h3>Capturing More Than One Type</h3>
						<pre><code trim-data>
trait Apart[F]{
  type T
  type W[X]

  def apply(f: F): W[T]
}
						</code></pre>
						<div class="fragment">
							<pre><code trim-data>
object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  implicit def mk[F[_], A] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F): W[T] = f
  }
}
							</code></pre>
						</div>
					</section>
					<section>
						<h3>An Aside</h3>
						<p>This is more than a type constructor</p>
						<pre><code trim-data>type W[X]</code></pre>
						<p>It is an equation.</p>
						<div class="fragment">
							<p>Valid declarations</p>
							<pre><code trim-data>
trait Demo[F[_]]{
  type W[X] = F[X]
  type Ignore[X] = F[Int]
  type Identity[X] = X
  type Const[X] = Int
}
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Type Refinements</h3>
						<pre><code trim-data>
object Apart{
  def apply[F](implicit apart: Apart[F]) = apart

  type Aux[FA, A, F[_]] = Apart[FA]{ type T = A; type W[X] = F[X] }

  implicit def mk[F[_], A] = new Apart[F[A]]{
    type T = A
    type W[X] = F[X]

    def apply(f: F): W[T] = f
  }
}
						</code></pre>
						<p>What does this give us?</p>
					</section>
					<section>
						<h3>Dependent Type Capture</h3>
						<div>
							<pre><code trim-data>
import scalaz._

def mapZero[Thing, F[_], A](thing: Thing)(implicit apart: Apart.Aux[T, A, F], 
                                                   f: Functor[F], 
                                                   m: Monoid[A]): F[A] =
  f(apart(thing))(_ => m.zero)
							</code></pre>
							<p>The Apart type class does not directly restrict the type of T.</p>
						</div>
						<div class="fragment">
							<pre><code trim-data>
def findZero[T, A](that: T)(implicit inner: Inner.Aux[T, A], 
                                     m: Monoid[A]): inner.T = m.zero
							</code></pre>
							<p> Here inner.T and A are equivalent. The type A is not a free parameter.</p>
						</div>
					</section>
					<section>
						<h3>Take Away</h3>
						<ol>
							<li>You are not restricted to a single abstract type when using dependent types.</li>
							<li>Type refinements can be used as a mechanism to capture the depedent types within the same implicit declaration.</li>
							<li>Captured types can be used by <i>other</i> type classes to place restrictions on related types.</li>
						</ol>
					</section>
				</section>

				<section>
					<section>
						<h3>Changing Behavior</h3>
						<p>Getting types is useful. Changing behavior due to types, that's really useful.</p>
						<pre><code trim-data>
object ApplyEither{
  def apply[T, F, G](t: T, f: F, g: G)
    (implicit ea: EApply[T, F, G]): ea.Out = ea(t, f, g)
}

trait EApply[T, F, G]{
  type Out

  def apply(t: T, f: F, g: G): Out
}
						</code></pre>
					</section>
					<section>
						<h3>Define EApply Creation</h3>
						<pre><code trim-data>
object EApply extends LowPriorityEApply{
  def apply[T, F, G](implicit ea: EApply[T, F, G]) = ea

  implicit def fapply[T, R, G] = new EApply[T, T => R, G] {
      type Out = R
      def apply(t: T, f: T => R, g: G) = f(t)
    }
}
trait LowPriorityEApply{
  implicit def gapply[T, R, F] = new EApply[T, F, T => R] {
      type Out = R
      def apply(t: T, f: F, g: T => R) = g(t)
    }
}
						</code></pre>
					</section>
					<section>
						<h3>In Action</h3>
						<pre><code trim-data>
val out = ApplyEither(1, {x: Int => 42}, {x: Double => "no"})
assert(out == 42)

val out2 = ApplyEither(2.0, {x: Int => 42}, {x: Double => "no"})
assert(out2 == "no")
						</code></pre>
						<p>The EApply trait acts as a compile time switch or case statement.</p>
					</section>
					<section>
						<h3>Take Away</h3>
						<ol>
							<li>Use implicit resolution order to avoid implicit ambiguity.</li>
							<li>Type level pattern matching can take advantage of implicit resolution order.</li>
						</ol>
					</section>
				</section>

				<section>
					<section>
						<h3>Walking the Type Structure</h3>
						<p>Limitations on Inner and Apart?</p>
						<pre><code trim-data>
case class Foo[V](value: V)

def zero[T, A](t: T)(implicit inner: Inner.Aux[T, A], 
                              m: Monoid[A]): inner.T = m.zero

zero(Foo(Foo(1))) //won't compile!
						</code></pre>
						<p>It only ever goes one level deep.</p>
					</section>
					<section>
						<h3>Recursive Structure?</h3>
						<p>Define another bland type like Inner</p>						
						<pre><code trim-data>
trait Unwrap[F]{
  type Inner
}
						</code></pre>
						<p>but...</p>
					</section>
					<section>
						<h3>Recurse Over the Types</h3>
						<pre><code trim-data>
object Unwrap extends LowPriorityUnwrap{
  def apply[F](implicit unwrap: Unwrap[F]) = unwrap

  implicit def neseted[F[_], G](implicit unwrap: Unwrap[G]) =
    new Unwrap[F]{
      type Inner = unwrap.Inner
    }
}
trait LowPriorityUnwrap{
  implicit def bottom[F[_], A] =
    new Unwrap[F[A]]{
      type Inner = A
    }
}
						</code></pre>
					</section>
					<section>
						<h3>Take Two</h3>
						<pre><code trim-data>
def zero[T, A](t: T)(implicit inner: Inner.Aux[T, A], 
                              m: Monoid[A]): inner.T = m.zero

val out = zero(Foo(Foo(1)))
assert(out == 0)
						</code></pre>
						<p>This compiles and now can access the inner type parameter of the nested Foo, Int.</p>
					</section>
					<section>
						<h3>Take Away</h3>
						<p>Dependent types can be used to pass type information around when solving for types.</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Doing Something Useful</h3>
						<p>Let's use types to guide the behavior of our application in a more direct manner. Who likes writing this?</p>
						<pre><code trim-data>
def annoy[A](that: Future[List[Set[Int]]], f: Int => A): Future[List[Set[A]]] =
  that map{ 
    _ map{
      _ map f
  }
}
						</code></pre>
					</section>
					<section>
						<h3>Define a Nested Mapper</h3>
						<pre><code trim-data>
object MapIt{
  def apply[A, B, C](in: A, f: B => C)
    (implicit mapper: Mapper[A, B, C]): mapper.Out =
      mapper(in, f)
}
trait Mapper[A, B, C]{
  type Out

  def apply(a: A, f: B => C): Out
}
						</code></pre>
					</section>
					<section>
						<h3>Define the Type Recursive Algorithm</h3>
						<pre><code trim-data>
object Mapper{
  def apply[A, B, C](implicit mapper: Mapper[A, B, C]) = mapper

  implicit def recur[F[_], A, B, C](implicit nested: Mapper[A, B, C], 
                                             f: Functor[F]) =
    new Mapper[F[A], B, C] {
      type Out = F[nested.Out]
      def apply(fa: F[A], g: B => C): Out = f.map(fa)(nested(_, g))
    }
  implicit def base[F[_], A, B >: A, C](implicit f: Functor[F]) =
    new Mapper[F[A], B, C]{
      type Out = F[C]
      def apply(fa: F[A], g: B => C) = f.map(fa)(g)
    }
}
						</code></pre>
					</section>
					<section>
						<h3>It Works! Right?</h3>
						<pre><code trim-data>
val in = List(List(1))
val out = MapIt(in, {x: Int => x+1})

assert(List(List(2)) == out)
						</code></pre>
					</section>
					<section>
						<h3>Or Does It?</h3>
						<p>Equality doesn't test the type. Be more type specific and compile this:</p>
						<pre><code trim-data>
identity[List[List[Int]]](out)
						</code></pre>
						<div class="fragment">
							<p>Scalac, you're a source of fun and assumement.</p>
							<pre>
type mismatch;

found: Mapper[List[List[Int]], Int, Int]#Out
required: List[List[Int]]
							</pre>
						</div>
					</section>
					<section>
						<h3>More Types to the Rescue</h3>
						<pre><code trim-data>
object Mapper{
  type Aux[A, B, C, Out0] = Mapper[A, B, C]{ type Out = Out0 }

  implicit def recur[F[_], A, B, C]
    (implicit nested: Mapper[A, B, C], 
              f: Functor[F]): Aux[F[A], B, C, F[nested.Out]] =

  implicit def base[F[_], A, B >: A, C]
    (implicit f: Functor[F]): Aux[F[A], B, C, F[C]] =
}
						</code></pre>
					</section>
					<section>
						<h3>Take Away</h3>
						<ol>
							<li>You can create the mother of all abstractions using dependent types.</li>
							<li>Type inference can fail in spectacular ways, especially with dependent types.</li>
							<li>Type refinement can help the compiler recapture "lost" type information.</li>
						</ol>
					</section>
				</section>

				<section>
					<section>
						<h3>Proving Algorithmic/Structural Correctness</h3>
						<ul>
							<p>If an algorithm or a structure has invariants, you can prove those invariants within the type system, i.e. if it compiles, it's correct!</p>
							<p>But... It works largely only at compilation time.</p>
						</ul>
					</section>
					<section>
						<h3>Balanced Tree</h3>
						<p>A balanced tree where the left branch must be greater than or equal to right branch in height.</p>
						<pre><code trim-data>
import shapeless._

sealed trait Tree[+T]{
  type N <: Nat
}
object Leaf extends Tree[Nothing]{
  type N = _0
}
trait Branch[T] extends Tree[T]{
  def left: Tree[T]
  def right: Tree[T]
}
						</code></pre>
					</section>
					<section>
						<h3>Another Aside</h3>
						<p>I'm cheating. I'm going to use Nat's from Shapeless. There's a few type classes/witnesses I get for free:</p>
						<ol>
							<li>Type level ordering: <code>LT[N,M]</code> and <code>LTEq[N,M]</code>. </li>
							<li>Type level operators: <code>Mult[N, M]</code>, <code>Div[N,M]</code>, <code>Sum[N,M]</code>, <code>Pow[N,M]</code> and <code>Min[N,M]</code>. </li>
							<li>Type level difference (where left Nat >= right Nat) <code>Diff[N,M]</code>. </li>
						</ol>
					</section>
					<section>
						<h3>The Proof</h3>
						<pre><code trim-data>
object Branch {
  type Aux[T, N0 <: Nat] = Branch[T] { type N = N0 }

  def apply[T, D <: Nat](value: T, left0: Tree[T], right0: Tree[T])
    (implicit diff: Diff.Aux[left0.N, right0.N, D],
              lte: LTEq[D, _1]): Aux[T, Succ[left0.N]] =
      new Branch[T] {
        val left = left0
        val right = right0
        type N = Succ[left0.N]
      }
}
						</code></pre>
					</section>
					<section>
						<h3>Does it Work?</h3>
						<pre><code trim-data>
val b1 = Branch(1, Leaf, Leaf)
val b2 = Branch(2, Leaf, Leaf)
val higher = Branch(3, b1, Leaf)
val higher2 = Branch(4, b2, b1)

val nope = Branch(42, higher, Leaf) //won't compile
val nadda = Branch(42, Leaf, b1) //won't do it either
						</code></pre>
						<p>Sure does!</p>
					</section>
					<section>
						<h3>Take Away</h3>
						<ol>
							<li>Any algorithm or data structure that makes use of this can be made proveably correct. If it compiles, it must work.</li>
							<li>The proof is, in general, a function of how you define and use it.</li>
						</ol>
					</section>
				</section>
				<section>
					<section>
						<h3>Less Restrictive Proofs</h3>
						<p>Always making the left hand side of the tree be greater than or equal to the right hand tree is a tough restriction to work within.</p>
					</section>
					<section>
						<h3>Removing the Left Hand Invariant</h3>
						<p>Ideally we'd want something that looks like this</p>
						<pre><code trim-data>
object Balanced{
  def apply[T, D <: Nat](value: T, left0: Tree[T], right0: Tree[T])
    (implicit diff: Diff.Aux[left0.N, right0.N, D],
              lte: LTEq[D, _1]): Aux[T, Succ[left0.N]] =

  def apply[T, D <: Nat](value: T, left0: Tree[T], right0: Tree[T])
    (implicit diff: Diff.Aux[right0.N, left0.N, D],
              lte: LTEq[D, _1]): Aux[T, Succ[right0.N]] =
}
						</code></pre>
						<p>This won't compile.</p>
					</section>
					<section>
						<h3>Take 2</h3>
						<pre><code trim-data>
object Balanced extends LowPriortyBalanced{
  def apply[T, D <: Nat](value: T, left0: Tree[T], right0: Tree[T])
    (implicit diff: Diff.Aux[left0.N, right0.N, D],
              lte: LTEq[D, _1]): Aux[T, Succ[left0.N]] =
}
trait LowPriorityBalanced{
  def apply[T, D <: Nat](value: T, left0: Tree[T], right0: Tree[T])
    (implicit diff: Diff.Aux[right0.N, left0.N, D],
              lte: LTEq[D, _1]): Aux[T, Succ[right0.N]] =
}
						</code></pre>
						<p>Compiles but doesn't work.</p>
					</section>
					<section>
						<h3>Use a Secondary Implicit</h3>
						<pre><code trim-data>
object Balanced{
  def apply[T](value: T, left0: Tree[T], right0: Tree[T])
    (implicit tb: TreeBuilder[T, left0.N, right0.N]): Branch.Aux[T, builder.Size] = 
      tb(value, left0, right0)

  trait TreeBuilder[T, N <: Nat, M <: Nat]{
    type Size <: Nat
    def apply(v: T, l: Tree[T], r: Tree[T]): Tree[T, Size]
  }

  object TreeBuilder{
    def apply[T, N <: Nat, M <: Nat](implicit tb: TreeBuilder[T, N, M]) = tb
  }
}
						</code></pre>
					</section>
					<section>
						<h3>Define TreeBuilder</h3>
						<pre><code trim-data>
						</code></pre>
					</section>
					<section>
						<h3>And The Right Hand Side</h3>
						<pre><code trim-data>
						</code></pre>
					</section>
					<section>
						<h3>Does it Work?</h3>
						<pre><code trim-data>
val one = Balanced(1, Leaf, Leaf)
val two = Balanced(2, Leaf, one)

identity[Branch.Aux[Int,_2]](two)
						</code></pre>
						<p>Yup!</p>
					</section>
					<section>
						<h3>Take Away</h3>
						<ol>
							<li>Multiple valid conditions sometimes require the use of a secondary witness/type class.</li>
							<li>The same structure can be used in multiple situations and with different invariants. Be careful.</li>
							<li>Sometimes the type refinement has to be recursively defined by the type that has paradoxically been "lost."</li>
						</ol>
					</section>
				</section>

				<section>
					<h1>Questions?</h1>					
				</section>

			</div>

		</div>

		<script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/head.min.js"></script>
		<script src="http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/js/reveal.min.js"></script>

		<script>
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				overview: true,
				touch: true,

				theme: 'sky',
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				dependencies: [
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/lib/js/classList.js', 
						condition: function() { return !document.body.classList; } 
					},
					{
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/markdown/marked.js', 
						condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/markdown/markdown.js', 
						condition: function() { return !!document.querySelector( '[data-markdown]' ); } 
					},
					{ 
						src: 'http://cdnjs.cloudflare.com/ajax/libs/reveal.js/2.6.2/plugin/highlight/highlight.js', 
						async: true, 
						callback: function() { hljs.initHighlightingOnLoad(); } 
					}
				]
			});

		</script>


	</body>
</html>
